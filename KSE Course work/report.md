# Отчёт по курсовой работе

### Введение

### Метод решения систем нелинейных уравнений

Есть несколько способов решения систем нелинейных уравнений. 
Мы выбрали _«Универсальный» метод_, который комбинирует в себе два других метода: 
_Метод градиентного спуска_ и _Метод Ньютона_.

1. Выбирается произвольный начльный вектор `res`
2. Каждую итерации выполняется метод градиентного спуска
   1. Находится градиент каждого уравнения системы в точке `х`: 
      
      `dx = grad (system) in x = res`, следующим образом:
      
      1. Вычсление значение функций в точке `х`: 
         
         `values = -system[i] (x) | i = 1..n`
         
      2. Вычисление матрицы Якоби в точке `х`:
         
         `jacobi = grad (system[i]) in x | i = 1..n `  
         
      3. Решение линейной системы методом гауса:
         
         `result = gauss (jacobi, values)`
   2. Находится локальный минимум системы в точке `х` и градиентом `dx`:
      
   3. Смещение результата на значение локального минимума `res = min * dx`
3. Если не достигнута необходимая точность, то повторить пункт 2.

В данном методе используется основная идея _Метода градиентного спуска_, 
но сама величина градиентного спуска ищется при помощи _Метода Ньютона_

### Решение задачи о конверсии хлороводорода (HCl) в хлориды алюминия (AlCln)

Требуется: ...

Составленная система уравнений (получена из уравнений приближённого термодинамического равновесия и условия "невхождения" элементов):

```java
Equation [] equations = {
  // 2 HCl + 2 Al = 2 AlCl + H2
  // Pe(HCl)^2 = K1 * Pe(AlCl)^2 * Pe(H2)
  v -> v [0] * v [0] - coefs [0] * v [1] * v [1] * v [4],
			
  // 2 HCl + Al = AlCl2 + H2
  // Pe(HCl) ^ 2 = K2 * Pe(AlCl2) * Pe(H2)
  v -> v [0] * v [0] - coefs [1] * v [2] * v [4],
			
  // 6 HCl + 2 Al = 2 AlCl3 + 3 H2
  // Pe(HCl)^6 = K3 * Pe(AlCl3)^2 * Pe(H2)^3
  v -> Math.pow (v [0], 6) - coefs [2] * v [3] * v [3] * Math.pow (v [4], 3),
			
  // G(Cl) = G(HCl) + G(AlCl) + 2 * G(AlCl2) + 3 * G(AlCl3) = 0
  // D(HCl) * (Pg(HCl) - Pe(HCl)) + D(AlCl) * (Pg(AlCl) - Pe(AlCl)) + 2 * D(AlCl2) 
  // ... * (Pg(AlCl2) - Pe(AlCl2)) + 3 * D(AlCl3) * (Pg(AlCl3) - Pe(AlCl3)) = 0
  v -> ds [0] * (press [0] - v [0]) + 2 * ds [4] * (press [4] - v [4]),
			
  // G(Cl) = G(HCl) + G(AlCl) + 2 * G(AlCl2) + 3 * G(AlCl3) = 0
  // D(HCl) * (Pg(HCl) - Pe(HCl)) + D(AlCl) * (Pg(AlCl) - Pe(AlCl)) + 2 * D(AlCl2)
  // ... * (Pg(AlCl2) - Pe(AlCl2)) + 3 * D(AlCl3) * (Pg(AlCl3) - Pe(AlCl3)) = 0
  v -> {
    double result = ds [0] * (press [0] - v [0]);
      for (int i = 1; i < 4; i++) {
        result += i * ds [i] * (press [i] - v [i]);
      }
		
      return result;
    }
  };
```
